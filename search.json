[{"categories":["hugo"],"content":"String类型转Integer类型： 1 Integer i = Integer.parseInt(str); String类型转Boolean类型： 1 Boolean b1 = Boolean.parseBoolean(str);\t//str=\"true\"或str=\"false\" 被static或final修饰的方法不能重写。 被abstract修饰的方法必须被重写。 abstract不能修饰属性和构造器。 final类不能被继承。 abstract类必须被继承。 接口与接口之间可以继承，而且可以多继承。 异常： 1 2 3 4 5 try{ ...... }catch(Exception e){ e.printStackTrace();\t//打印异常信息，等于System.out.println(e.getMessage()); }\t创建一个线程类： 1 2 3 class MyThread extends Thread{ ...... } 创建一个线程类： 1 2 3 4 class MyThread implements Runnable{ @Override Public void run(){\t...\t} } 线程中的同步监视器(锁)： 1 2 3 synchronized(this){ ...... } 线程(Thread类)的常用方法： 1. start()：启动当前线程，调用当前线程的run()。 2. run()：通常需要重写Thread类中的此方法，将创建的额线程执行的操作声明在此方法中。 3. currentThread()：静态方法，返回当前正在执行的线程。 4. getName()：获取当前线程的名字。 5. setName()：设置当前线程的名字。 6. yield()：释放当前CPU的执行权。 7. join()：在线程a中调用线程b的join()，此时线程a进入阻塞状态，直到线程b完全执行后，线程a才结束阻塞。 8. stop()：强制结束线程，已过时，不推荐使用。 9. sleep(long 毫秒)：让线程“睡眠”指定的毫秒数，在指定的毫秒数完事，恢复执行。 10. isAlive()：判断当前线程是否存活，得到一个boolean类型的结果。 多线程，我们是无法完全控制线程的执行顺序，谁执行，谁不执行，概率问题。 线程的优先级： 1 2 3 4 5 6 public static final int MIN_PRIORITY = 1; NORM_PRIORITY = 5; MAX_PRIORITY = 10; setPriority(int newPriority);\t//设置优先级 getPriority();\t//获取优先级 //不能有sleep() 高优先级的线程要抢占低优先级线程的cpu执行权，但是只是从概率上讲，高优先级的线程高概率下被执行，并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。 实现Runnable接口方式创建多线程： 1. 创建一个实现了Runnable接口的类。 2. 实现类去实现Runnable中的抽象方法：run()。 3. 创建实现类的对象。 4. 将此对象作为参数传递到Thread构造器中，创建Thread类的对象。 5. 通过Thread类的对象调用start()方法。 开发中优先选择：实现Runnable接口的方式。原因是因为实现Runnable接口的方式没有类的单继承性的局限性，实现Runnable接口的方式更适合来处理多个线程有共享数据的情况。 两者的联系： 1. Thread类本身也是实现了Runnable接口。 2. 两种方式都需要重写run()，将线程要执行的逻辑写在run()中。 如果一个类通过这两种方式成为多线程，必须直接或间接的实现Runnable接口。 线程的生命周期：新建、就绪、运行、阻塞、死亡。 解决卖票问题： 1. 操作共享数据的代码，需将其写在同步代码块里，不能包含的多，也不能包含的少。 2. 共享数据：多个线程共同操作的变量，比如：ticket就是共享的数据。 3. 同步监视器又叫锁，任何一个类的对象都可以充当锁。 要求多个线程必须用同一把锁。 如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明为同步的。 总结： 1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。 2. 非静态的同步方法，同步监视器是this。 静态的同步方法，同步监视器是当前类本身。 好处：同步的方式，解决了线程的安全问题。 坏处：操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 死锁： 1. 不同的线程分别占用对方需要的同步资源不放弃，都在等对方放弃自己需要的同步资源。 2. 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态。 synchronized和lock的区别： 相同：二者都可以解决线程安全问题。 不同：synchronized机制在执行完相应的代码后，自动释放同步监视器；lock需要手动的启动同步（lock()），同时结束同步也需要手动实现（unlock()）。 生产者与消费者(设计模式)： wait()：当执行此方法，当前线程就进入阻塞状态，并释放同步监视器。 notify()：当执行此方法，会唤醒被wait()的一个线程。若有多个线程被wait()，会唤醒优先级较高的那个线程。 notifyAll()：唤醒所有等待的线程。 wait()，notify()和notifyAll()：必须使用在同步代码块或同步方法中，三个方法的调用者必须是同步代码块或同步方法中的同步监视器，否则会出现异常，它们定义在Object类中。 sleep()和wait()的异同： 相同点：一旦执行方法，都可以使当前线程进入阻塞状态。 不同点： 1. 声明位置不同sleep—\u003eThread wait—\u003eObject。 2. 调用的要求不同：sleep可以在任何需要的地方调用。wait，只能在同步代码块或同步方法调用。 3. 是否释放同步监视器：如果两个方法都在线程同步中，sleep不会释放同步锁，wait会释放同步锁。 需求：生产者(Producer)将产品交给店员(Clerk)，消费者(Customer)从店员处取走产品，店员一次能持有固定数量的产品(20)，如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，当店中有产品了再通知消费者可以购买。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 //生产者 class Producer extends Thread { private Clerk clerk; public Producer(Clerk clerk){ this.clerk = clerk; } @Override public void run() { System.out.println(getName() + \"：开始生产产品\"); while(true){ try { Thread.sleep(10000); } catch (InterruptedException e) { e.printStackTrace(); } clerk.produceProduct(); } } } //消费者 class Customer extends Thread{ private Clerk clerk; public Customer(Clerk clerk){ this.clerk = clerk; } @Override public void run() { System.out.println(getName() + \"：开始消费产品\"); while(true){ try { Thread.sleep(10000); } catch (InterruptedException e) { e.printStackTrace(); } clerk.consumeProduct(); } } } //服务员 class Clerk{ private int productCount = 0; //生产产品 public synchronized void produceProduct(){ if(productCount \u003c 20){ productCount++; System.out.println(Thread.currentThread().getName() + \"：开始生产第\" + productCount + \"个产品\"); notifyAll(); }else{ try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } //消费产品 public synchronized void consumeProduct(){ if(productCount \u003e 0){ System.out.println(Thread.currentThread().getName() + \"：开始消费第\" + productCount + \"个产品\"); productCount--; notify(); }else{ try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } public class Test { public static void main(String[] args) { Clerk clerk = new Clerk(); Producer p = new Producer(clerk); p.setName(\"生产者1\"); Customer c1 = new Customer(clerk); c1.setName(\"消费者1\"); Customer c2 = new Customer(clerk); c2.setName(\"消费者2\"); Customer c3 = new Customer(clerk); c3.setName(\"消费者3\"); p.start(); c1.start(); c2.start(); c3.start(); } } String声明为final的，不可被继承。 String实现了Serializable接口，表示字符串是支持序列化。 String实现了Comparable接口，表示字符串是可以比较大小。 String内部定义了final char[] value用于存储字符串数据。 字符串常量池中是不会存储相同内容的字符串的。 String类的一些方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //是否以指定的字符串结束，返回值是Boolean类型 System.out.println(str.endsWith(\"123\"));\t//是否以指定的字符串开头，返回值是Boolean类型 System.out.println(str.startsWith(\"he\"));\t//从字符串下标为1的位置开始截取，直到末尾 System.out.println(str.substring(1));\t//从字符串下标为0的位置开始截取，截取到下标为3的位置，不包含结束下标位置的字符 System.out.println(str.substring(0, 3));\t//比较两个字符串的大小，返回正数，0和负数 System.out.println(str.compareTo(str1));\tSystem.out.println(str.concat(str1));\t//字符串的连接，等价于用 + 拼接 //忽略大小写比较字符串是否相等 System.out.println(str.equalsIgnoreCase(str1));\tSystem.out.println(str.equals(str1));\t//比较字符串的内容是否相等 System.out.println(str == str1);\t//比较字符串的内容是否相等 System.out.println(str.trim());\t//返回字符串去除前后空格的副本 System.out.println(str.toUpperCase());\t//将字符串转换成大写字母 System.out.println(str.toLowerCase());\t//将字符串转换成小写字母 System.out.println(str.isEmpty());\t//判断是否是空字符串 System.out.println(str.length == 0);\t//判断是否是空串 System.out.println(str.charAt(0));\t//取出指定下标位置的字符 System.out.println(str.length());\t//返回字符串的长度 字符串的拼接操作： 1 2 3 4 5 6 7 String s1 = \"javaEE\"; String s2 = \"hadoop\"; String s3 = \"javaEEhadoop\"; String s6 = (\"javaEE\" + s2).intern(); String s7 = s1 + s2; System.out.println(s3 == s6);\t//true System.out.println(s6 == s7);\t//false String类的一些方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 String str = \"he-ll-o-wo-rl-d\"; //根据指定的条件拆分，最多不能超过3个元素，如果超过了，剩下的全部放在最后一个元素中 System.out.println(Arrays.toString(str.split(\"-\", 3))); String[] strs = str.split(\"-\");\t//根据指定的条件拆分字符串 //想打印数组中的内容，直接调用toString()只会打印出数组的地址，因此需要使用Arrays.toString() System.out.println(Arrays.toString(strs));\t//打印strs字符串的内容 //使用给定的内容替换第一个字符串 System.out.println(str.replaceFirst(\"l\", \"o\"));\tSystem.out.println(str.replaceAll(\"ello\", \"i\"));//使用给定的内容替换字符串 //将字符串中的e替换成f，返回替换后的字符串 System.out.println(str.replace('e', 'f'));\t//从右向左找，第一次出现的索引，说明字符串的索引永远是从左向右排 System.out.println(str.lastIndexOf(\"l\"));\tSystem.out.println(str.lastIndexOf(\"l\", 2)); System.out.println(str.indexOf(\"1\", 3)); //返回指定的子字符串在此字符串中第一次出现的索引，如果没找到，返回-1 System.out.println(str.indexOf(\"l\")); //当且仅当此字符串包含指定的char值序列时，返回true System.out.println(str.contains(\"he\")); String与char[]之间的转换： 1 2 3 4 5 6 7 String str = \"abcd\"; char[] chars = str.toCharArray();\t//String-\u003echar[]，调用String的toCharArray() System.out.println(Arrays.toString(chars)); char [] chars1 = new char[]{'x','y','z'}; //char[]-\u003eString，调用String的构造器 String str1 = new String(chars1);\tSystem.out.println(str1); String与byte[]之间的转换: 1 2 3 4 5 6 7 8 String str = \"abcd\"; //编码:String-\u003ebyte[]，调用String的getBytes() byte[] bytes = str.getBytes();\tSystem.out.println(Arrays.toString(bytes));\t//输出的是ASCII码 byte [] bytes1 = new byte[]{97,98,99,100}; //解码:byte[]-\u003eString，调用String的构造器 String str1 = new String(bytes1);\tSystem.out.println(str1) String，StringBuffer，StringBuilder三者的异同： String是不可变的！String可以直接用字面量(等号)赋值，底层是char[]存储。 StringBuffer和StringBuilder是可变的！必须通过构造器赋值。 StringBuffer和StringBuilder，从使用上来说，没区别。 StringBuffer：从jdk1.0就有，线程同步的，线程安全，效率低，底层是char[]存储。 StringBuilder：从jdk1.5才有，线程异步的，线程不安全，效率高，底层是char[]存储。 增：append、删：delete、改：replace / setCharAt、查：charAt、插：insert、长度：length。 遍历：for + charAt / toString —\u003e toCharArray + for。 三种字符串的效率从高到低排列： StringBuilder \u003e StringBuffer \u003e String 。 StringBuilder的增删改查： 1 2 3 4 5 6 7 StringBuilder strb = new StringBuilder(\"hello\"); strb.append(\"world\");\t//字符串的拼接 strb.delete(1,3);\t//字符串的删除 strb.replace(0,2,\"sss\");\t//字符串的替换 strb.insert(1,\"xxx\");\t//字符串的插入 strb.reverse();\t//字符串的反转 System.out.println(strb); StringBuilder和String的转换： 1 2 StringBuilder strb = new StringBuilder(\"hello\");//String-\u003eStringBuilder，调用构造器 String s = strb.toString();\t//StringBuilder-\u003eString，调用toString()方法 一些时间工具类： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //返回系统当前时间距离1970年1月1日0时0分0秒之间的毫秒数，东八区(时间戳) long start = System.currentTimeMillis(); //把date类型的日期转换为String类型的字符串，可以调用String类的方法 String dateStr = date.toString(); Date date = new Date();\t//获取系统当前时间：年月日，时分秒，星期，时区 System.out.println(date); Date date1 = new Date(1589365389708L);\t//1589365389708 Wed May 13 18:23:09 CST 2020 System.out.println(date1); //java.sql.Date只有一个构造器，传入long类型的构造器，它和数据库的Date类型匹配 java.sql.Date date = new java.sql.Date(1589365389708L); System.out.println(date); Date date1 = date;\t//sql.Date-\u003eutil.Date：直接赋值，多态 System.out.println(date1); Date date2 = new Date();\t//util.Date-\u003esql.Date：直接赋值，多态 java.sql.Date date3 = new java.sql.Date(date2.getTime()); Date time = calendar.getTime();\t//获取系统当前时间，calendar-\u003eDate System.out.println(time); Calender日历类(抽象类)： 实例化方式一：创建其子类的对象。 实例化方式二：调用其静态方法getInstance() 。 1 2 3 4 5 6 7 8 9 Calendar calendar = Calendar.getInstance(); System.out.println(calendar.get(Calendar.DAY_OF_MONTH)); System.out.println(calendar.get(Calendar.DAY_OF_YEAR)); calendar.set(Calendar.DAY_OF_MONTH,22); System.out.println(calendar.get(Calendar.DAY_OF_MONTH)); calendar.add(Calendar.DAY_OF_MONTH,10); System.out.println(calendar.get(Calendar.DAY_OF_MONTH)); System.out.println(\"月份：\" + (calendar.get(Calendar.MONTH) + 1)); System.out.println(\"星期：\" + Ch02.weekHandle(calendar.get(Calendar.DAY_OF_WEEK 注意事项： 使用Calendar获取月份时，一月是0，二月是1，…，十二月是11。 使用Calendar获取星期时，从星期日开始计算的，周日是1，周一是2，…，周六是7。 Date和字符串的转换： 1 2 3 4 5 6 7 8 Date date = new Date(); System.out.println(date); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss.SSS\"); String format = sdf.format(date);\t//格式化：Date-\u003e字符串 System.out.println(format); String str = \"2020年02月02日 14:02:02.222\"; Date parse = sdf.parse(str);\t//解析(格式化的逆过程)：字符串-\u003eDate System.out.println(parse); Java中的比较： 1. Java中的对象，正常情况下，只能进行比较： == 和 != ，不能使用 \u003e 和 \u003c ，但是在开发场景中，我们要对多个对象进行排序，就是比较对象的大小。实现方法是使用两个接口中的任意一个：Comparable或Comparator。 2. Comparable接口：自然排序 (1). 像String、包装类实现了Comparable接口，重写compareTo()，给出两个对象的比较大小的方式。 (2). 像String、包装类重写compareTo方法以后，进行的从小到大的排列。 3. 重写compareTo的规则： (1). 如果当前对象this大于形参对象的obj，返回正整数。 (2). 如果当前对象this小于形参对象obj，返回负整数。 (3). 如果当前对象this等于形参对象obj，返回0。 4. 对于我们自定义的类来说，如果需要排序，我们可以让自定义的类实现Comparable接口，重写compareTo方法，在compareTo方法中，指明排序规则。 Comparator接口的使用：定制排序 1. 当元素的类型没有实现Comparable接口，不方便修改源代码，或者实现了Comparable接口，但是排序规则不适合当前操作，那么可以考虑使用Comparator接口。 2. 重写compare方法，比较两个形参的大小。如果返回正整数，则o1大于o2，如果返回负整数，则o1小于o2，如果返回0，o1等于o2。 Comparable接口和Comparator接口的对比： Comparable接口的方式一旦指定，保证Comparable接口实现类的对象在任何位置都可以比较大小。 Comparator接口属于临时比较。 一些Math方法： 1 2 3 4 5 6 7 8 9 10 //随机数：0-1的随机小数，double类型，不包括0也不包括1 System.out.println(Math.random());\t//生成0-100的随机整数，不包括0，也不包括100 System.out.println(Math.round(Math.random() * 100)); //生成0-100的随机整数，既包括0，也包括100 System.out.println((int) (Math.random() * 100)); System.out.println(Math.cbrt(8));\t//返回8的立方根 System.out.println(Math.ceil(-4.1));\t//向上取整 System.out.println(Math.floor(4.9));\t//向下取整 System.out.println(Math.round(4.5));\t//四舍五入 BigDecimal类： Java在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。 1 2 3 4 5 6 7 8 BigDecimal bi1 = new BigDecimal(\"1.5\"); BigDecimal bi2 = new BigDecimal(\"1.1\"); double d1 = 0.5; double d2 = 0.1; System.out.println(d1 - d2); System.out.println(bi1.divide(bi2)); System.out.println(bi1.add(bi2)); System.out.println(bi1.divide(bi2, BigDecimal.ROUND_HALF_DOWN)); BigInteger类： java中有两个类BigInteger和BigDecimal分别表示大整数类和大浮点数类。 1 2 3 4 5 BigInteger bi1 = new BigInteger(\"32132132132132132\"); BigInteger bi2 = new BigInteger(\"654878654895465465\"); System.out.println(bi1.add(bi2)); System.out.println(bi1.divide(bi2)); System.out.println(bi1.subtract(bi2)); 常用正则表达式规范： \\\\：表示反斜线\\。 \\t：表示制表符。 \\n：表示换行符。 [abc]：表示字符a,b,或c。 [^abc]：表示除了a,b,c之外的任意字符。 [a-zA-Z0-9]：字母、数字组成。 \\d：表示数字。 \\D：表示非数字。 \\w：表示字母、数字、下划线。 \\W：表示非字母、数字、下划线。 \\s：表示所有的空白字符(换行、空格)。 \\S：表示所有的非空白字符。 ^：行的开头。 $：行的结尾。 . ：匹配除换行之外的任意字符。 +：表示1位以上。 正则表达式： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 String str = \"aaaaaaaa1234567890\"; //[0-9]+就是一个正则表达式，代表由1个以上的0-9的数字组成 boolean b = str.matches(\"[0-9]+\");\tif(b){ System.out.println(\"是由纯数字组成\"); }else{ System.out.println(\"不是由纯数字组成\"); } str = \"a1b2c3d4e5f6\"; //split()是根据指定的条件拆分字符串 String[] split = str.split(\"[0-9]\");\tSystem.out.println(Arrays.toString(split));\tstr = \"@qq.com\"; String regex = \"^[A-Za-z0-9\\\\u4e00-\\\\u9fa5]+@[a-zA-Z0-9_-]+(\\\\.[a-zA-Z0-9_-]+)+$\"; System.out.println(str.matches(regex)); 邮箱的正则表达式： 1 ^[A-Za-z0-9\\u4e00-\\u9fa5]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$ 枚举类： 季节的枚举类，一年只能有四个季节，对象都是static。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 enum Season { //1.提供当前枚举类的对象，多个对象之间用,隔开，末尾对象用;结束 SPRING(\"春天\",\"春暖花开\"), SUMMER(\"夏天\",\"夏日炎炎\"), AUTUMN(\"秋天\",\"秋高气爽\"), WINTER(\"冬天\",\"冰天雪地\"); //2.声明Season对象的属性，private final修饰 private final String seasonName; private final String seasonDesc; //3.私有化构造器，并给属性赋值 private Season(String seasonName,String seasonDesc){ this.seasonName = seasonName; this.seasonDesc = seasonDesc; } //4.其他诉求，提供具体属性的get方法 public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; } } Season spring = Season.SUMMER; System.out.println(spring.getSeasonName() + \"-\u003e\" + spring.getSeasonDesc()); Season s1 = new Season(); switch(spring){ case SPRING: case SUMMER: case AUTUMN: case WINTER: } Collection接口：存放单值的最大父接口。 Map接口：存放对值的最大父接口。 数组： 创建数组时要指定数组的长度。 1 2 3 int [] arr = new int[10]; arr[0] = 1; Object [] arr = new Object[10]; Collection集合： 创建集合不需要指定集合的大小。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Collection coll = new ArrayList(); coll.add(123);\t//向集合中添加数据，默认是Object类型的数据 coll.add(456); coll.add(new String(\"Tom\")); coll.add(false); coll.add(new Person(\"Jerry\",20)); System.out.println(coll); //contains()：判断集合中是否包含某个数据，调用传入对象的equals()来比对，返回boolean System.out.println(coll.contains(new Person(\"Jerry\",20))); //Arrays.asList()是将数组转化成List集合的方法，用此方法得到的List的长度是不可改变的 Collection coll1 = Arrays.asList(123, 456,789); //containsAll()：判断形参coll中的所有元素是否存在于当前集合中，返回boolean System.out.println(coll.containsAll(coll1)); //remove()：从当前集合中移除元素，返回boolean System.out.println(coll.remove(123)); //removeAll()：从当前集合中移除coll1中所有的元素 System.out.println(coll.removeAll(coll1)); System.out.println(coll); //retainAll()：交集，获取当前集合和coll1集合的交集，并返回给当前集合 System.out.println(coll.retainAll(coll1)); System.out.println(coll); 如果你的List只是用来遍历，就用Arrays.asList()。 如果你的List还要添加或删除元素，还是乖乖地new一个java.util.ArrayList，然后一个一个的添加元素。 Collection集合的一些方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new String(\"Tom\")); coll.add(false); coll.add(new Person(\"Jerry\",20)); Collection coll2 = new ArrayList(); coll2.add(123); coll2.add(456); coll2.add(new String(\"Tom\")); coll2.add(false); coll2.add(new Person(\"Jerry\",20)); //equals()：要想返回true，需要当前集合和形参集合的元素相同 //其比较的不是虚地址,equals()是ArrayList重写过的 System.out.println(coll.equals(coll2)); //hashCode()：返回当前对象的哈希值 System.out.println(coll.hashCode()); 集合和数组之间的相互转换： 1 2 3 4 5 6 7 8 9 10 11 12 Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new String(\"Tom\")); coll.add(false); coll.add(new Person(\"Jerry\",20)); Object[] arr = coll.toArray();\t//集合-\u003e数组：调用toArray() for (int i = 0; i \u003c arr.length; i++) { System.out.println(arr[i]); } String [] arrStr = new String[]{\"a\",\"b\",\"c\"}; Collection collStr = Arrays.asList(arrStr);\t//数组-\u003e集合：调用Arrays.asList() 集合元素的遍历： 集合元素的遍历操作，使用迭代器Iterator接口。 1. 内部的方法：hasNext和next()。 2. 集合对象每次调用iterator方法，都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。 3. 内部定义了remove()，可以在遍历的时候，删除集合中的元素。 4. 如果没有调用next方法，不要调用remove，不能调两次remove。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new String(\"Tom\")); coll.add(false); coll.add(new Person(\"Jerry\",20)); Iterator iterator = coll.iterator(); while(iterator.hasNext()){ String s = iterator.next() + \"-\u003e1\"; System.out.println(s); Object next = iterator.next(); if(\"Tom\".equals(next)){ iterator.remove(); } } System.out.println(coll); 增强for循环遍历集合元素： 1 2 3 4 5 6 7 8 9 10 Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new String(\"Tom\")); coll.add(false); coll.add(new Person(\"Jerry\",20)); for (Object o : coll) { System.out.println(o); } System.out.println(coll.size());\t//返回集合的大小 ArrayList、LinkedList和Vector的异同： 相同点：三个类都实现了List接口，存储数据的特点是相同。 不同点： ArrayList：作为List接口的主要的实现类，线程不安全的，效率高。底层是使用数组存储数据。 LinkedList：对于频繁的插入、删除操作，使用此类效率会比ArrayList高；底层使用双向链表。 Vector：作为List接口古老的实现类，线程安全的，效率低；底层使用数组。 List集合的特点：有顺序的(添加的先后顺序)，可以重复的。 List接口是Collection接口的子接口，Collection接口中的方法都可以使用。 ArrayList集合： JDK7及以前版本，如果调用ArrayList的空参构造器创建集合，底层是会开辟一个类似Object [] elementData = new Object[10]; 如果添加的数据大于10个，elementData数组容量不够，则会扩容，默认情况下，扩容为原来的1.5倍，同时需要将原数组中的数据复制到新的数组中。 JDK8版本，调用ArrayList的空参构造器创建集合，不会创建长度为10的数组，调用add方法时，才会创建长度为10的数组，延迟加载后续的添加内容与jdk7无异。 建议在开发中使用带参构造器。 1 2 3 4 5 6 7 8 9 10 11 12 ArrayList list = new ArrayList(Integer.MAX_VALUE); list.add(123); list.add(456); list.add(\"aa\"); list.add(new Person(\"张三\",25)); list.add(456); System.out.println(list); list.add(1,\"bb\");\t//在指定位置插入元素 List\u003cInteger\u003e list1 = Arrays.asList(1, 2, 3); list.addAll(1,list1);\t//在指定位置开始插入一个集合元素 System.out.println(list); System.out.println(list.get(0));\t//取出指定下标位置的元素 ArrayList集合的一些方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ArrayList list = new ArrayList\u003c\u003e(); list.add(123); list.add(456); list.add(\"aa\"); list.add(new Person(\"张三\",25)); list.add(456); //返回元素首次出现的位置，找不到返回-1 System.out.println(list.indexOf(456));\tSystem.out.println(list.lastIndexOf(456));\t//返回元素最后一次出现的位置 //删除指定位置的元素，并返回此元素 System.out.println(list.remove(new Integer(456)));\tSystem.out.println(list); list.set(0,\"哈哈\");\t//设置指定下标位置的元素 System.out.println(list); //返回子集合，包括开始，不包括结束 System.out.println(list.subList(2, 4));\tfor循环遍历ArrayList集合： 1 2 3 4 5 6 7 8 9 ArrayList list = new ArrayList\u003c\u003e(); list.add(123); list.add(456); list.add(\"aa\"); list.add(new Person(\"张三\",25)); list.add(456); for (int i = 0; i \u003c list.size(); i++) { System.out.println(list.get(i)); } LinkedList集合： 集合内部声明了Node类型的first和last属性，默认值为null。 Node定义为体现了LinkedList双向链表的说法，不涉及扩容，只有数组涉及扩容。 1 2 3 4 5 6 7 8 9 LinkedList list = new LinkedList(); list.add(123);\t//将123封装到Node中，创建了Node对象 list.add(456); list.add(\"aa\"); list.add(new Person(\"张三\",25)); list.add(456); list.addFirst(100); list.removeFirst(); System.out.println(list); Vector集合： JDK7和JDK8，通过Vector构造器创建对象时，底层创建了长度为10的数组。在扩容方面，扩容为原数组长度的2倍，Vector的方法同ArrayList的方法。 1 2 3 4 5 6 Vector list = new Vector(); list.add(123); list.add(456); list.add(\"aa\"); list.add(new Person(\"张三\",25)); list.add(456); List接口：有序的，数据可以重复的。 Set接口：无序的，不是按照添加的先后顺序排列，数据不可以重复。 Set接口的实现类： 1. HashSet：作为set接口的主要的实现类，线程不安全，可以存null值，效率高。 2. LinkedHashSet：作为HashSet的子类，遍历其内部数据时，可以按照添加的顺序遍历。 3. TreeSet：可以按照添加对象的指定属性进行排序。 Set接口中没有额外定义的新的方法，使用的都是Collection中声明过的方法。 要求： 向Set中添加的数据，其所在的类一定要重写hashCode()和equals()。 1. Set接口无序，不可重复的数据，以HashSet为例说明： (1). 无序性：不等于随机性，存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据哈希值决定的。 (2). 不可重复性：保证添加的元素按照equals()判断时，不能返回true，即：相同的元素只能添加一个。 2. 添加元素的过程，以HashSet为例： 我们向HashSet中添加元素a，首先调用元素a的所在类的hashCode()方法，计算元素a的哈希值，此哈希值通过某种算法计算出现在HashSet底层数组中的存放位置(索引位置)，判断此数组此位置上是否已经有元素，如果此位置上没有其他元素，则元素a添加成功(情况1)，如果此位置上有其他元素b，比较元素a和元素b的哈希值，如果哈希值不相同，则元素a添加成功(情况2)，如果哈希值相同，进而需要调用元素a的所在类的equlas方法，equals()返回true，元素a添加失败，equals()返回false，则元素a添加成功(情况3)，对于添加成功的情况2和情况3，元素a与已经存在指定索引位置上的数据以链表的方式存储。 HashSet底层：数组 + 链表。 HashSet集合： 1 2 3 4 5 6 7 HashSet set = new HashSet(); set.add(123); set.add(\"hello\"); set.add(false); set.add(new Person(\"张三\",25)); set.add(123); System.out.println(set); LinkedHashSet集合： 1 2 3 4 5 6 7 LinkedHashSet set = new LinkedHashSet(); set.add(123); set.add(\"hello\"); set.add(false); set.add(new Person(\"张三\",25)); set.add(123); System.out.println(set); Set集合： 1 2 3 4 5 6 7 8 9 Set set = new HashSet(); set.add(123); set.add(\"hello\"); set.add(\"hello\"); set.add(false); set.add(new Person(\"张三\",25)); set.add(123); set.add(new Person(\"张三\",25)); System.out.println(set); 向TreeSet中添加的数据，要求是相同的对象。 两种排序方式：自然排序(实现Comparable接口)，定制排序。 如果在TreeSet排序过程中，目标对象已经实现了Comparable接口，并且已经定义了自然排序的规则，在创建TreeSet对象时，又指定了定制排序，以定制排序的规则为准。 TreeSet集合： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 TreeSet set1 = new TreeSet(); set.add(1); set.add(-189); set.add(\"haha\"); set.add(false); set.add(new Person(\"张三\",25)); set.add(89); set.add(55); set.add(1000); System.out.println(set); TreeSet set2 = new TreeSet(); set.add(new User(\"aaa\",30));\t//3 set.add(new User(\"aaa\",40));\t//4 set.add(new User(\"bbb\",20));\t//2 set.add(new User(\"ccc\",50));\t//1 System.out.println(set); 按照年龄从小到大排序： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Comparator com = new Comparator() { @Override public int compare(Object o1, Object o2) { if(o1 instanceof User \u0026\u0026 o2 instanceof User){ User u1 = (User) o1; User u2 = (User) o2; return Integer.compare(u1.getAge(),u2.getAge()); }else{ throw new RuntimeException(\"传入的类型不匹配...\"); } } }; TreeSet set = new TreeSet(com); set.add(new User(\"aaa\",30));\t//3 set.add(new User(\"aaa\",40));\t//4 set.add(new User(\"bbb\",20));\t//2 set.add(new User(\"ccc\",50));\t//1 System.out.println(set); Map接口：键值对，无序，key不可以重复，value可以重复。 HashMap：作为Map的主要的实现类，线程不安全，效率高，可以存储null的key和value。 LinkedHashMap：保证在遍历Map元素时，可以按照添加的顺序实现遍历。 TreeMap：可以按照添加的key—value对进行排序，根据key排序，自然排序和定制排序。 Hashtable：作为Map的古老的实现类，线程安全的，效率低，不能存储null的key，可以存null的value。 Properties：常用来处理配置文件，key和value都是String类型。 jdk7之前的底层结构：数组 + 链表。 jdk8以后的底层结构：数组 + 链表 + 红黑树。 Map内部结构： Map中的key：无序的，不可重复的，使用Set存储所有的key—\u003ekey所在的类重写equals()和hashCode()。 Map中的Value：无序的，可重复的，使用Collection存储所有的value—\u003evalue所在的类要重写equals()。 一个键值对：key—value构成了一个Entry对象。 Map中的Entry：无序的，不可重复的，使用Set存储所有的Entry。 JDK7的情况(以HashMap为例)： 在实例化以后，底层创建了长度为16的一维数组Entry [] table。 添加数据： 首先，调用key1所在的类的hashCode()计算key1哈希值，此哈希值经过某种算法后，得到在Entry[]数组中的位置。若此位置上的数据为空，key1–value1添加成功(情况1)，如果此位置上的数据不为空，意味着此位置上存在一个或多个数据(以链表形式存在)，比较key1和已经存在的一个或多个数据的哈希值，如果key1的哈希值与已经存在数据的哈希值都不同，此时key1–value1添加成功(情况2)，如果key1的哈希值和已经存在的某一个数据的哈希值相同，继续比较，调用equals()比较，如果equals()返回false：key-value1添加成功(情况3)，若equals()返回true，使用value1替换原有数据，情况2和情况3此时的key1-value1和原来的数据以链表的形式存储。 JDK8的情况(以HashMap为例)： 1. 在实例化以后，没有创建一个长度为16的数组。 2. JDK底层的数组是Node[]，而非Entry[]。 3. 添加数据时，创建一个长度为16的数组。 JDK7底层只有数组 + 链表，JDK8底层有数组 + 链表 + 红黑树。 Map集合： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Map map = new HashMap(); map.put(\"AA\",123);\t//添加 map.put(45,123); map.put(\"BB\",56); map.put(\"AA\",87);\t//修改 System.out.println(map); Map map1 = new HashMap(); map1.put(\"CC\",123); map1.put(\"DD\",123); map.putAll(map1);\t//添加一个集合 System.out.println(map); Object cc = map.remove(\"CC\");\t//删除 System.out.println(cc); System.out.println(map); map.clear();\t//清空map，把集合中的元素清空，不是map = null System.out.println(map); Map集合： 1 2 3 4 5 6 7 8 9 10 Map map = new HashMap(); map.put(\"AA\",123); map.put(45,123); map.put(\"BB\",56); //查询：根据传入的key，取出对应的value，若key不存在，返回null System.out.println(map.get(45));\tSystem.out.println(map.containsKey(\"BB\"));\t//判断是否包含某个key System.out.println(map.containsValue(123));\t//判断是否包含某个value map.clear(); System.out.println(map.isEmpty());\t//判断map集合是否为空 Map集合： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Map map = new HashMap(); map.put(\"AA\",123); map.put(45,123); map.put(\"BB\",56); Set set = map.keySet();\t//遍历所有的key for (Object o : set) { System.out.print(o + \",\"); } System.out.println(); Collection values = map.values();\t//遍历所有的value for (Object value : values) { System.out.print(value + \",\"); } System.out.println(); for (Object o : set) {\t//遍历key和value System.out.print(o + \"-\u003e\" + map.get(o) + \",\"); } System.out.println(); Set set1 = map.entrySet();\t//操作Entry for (Object o : set1) { Map.Entry entry = (Map.Entry) o; System.out.print(entry.getKey() + \"-\u003e\" + entry.getValue() + \",\"); } System.out.println(); for (Map.Entry entry : map.entrySet()) {}\t//另一种遍历方法 TreeMap集合： 1 2 3 4 5 6 7 8 9 10 TreeMap map = new TreeMap(); map.put(new User(\"Tom\",23),98); map.put(new User(\"Jerry\",32),89); map.put(new User(\"Jack\",20),76); map.put(new User(\"Rose\",18),100); Set set = map.entrySet(); for (Object o : set) { Map.Entry entry = (Map.Entry) o; System.out.println(entry.getKey() + \"-\u003e\" + entry.getValue()); } TreeMap集合： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 TreeMap map = new TreeMap(new Comparator() { @Override public int compare(Object o1, Object o2) { if(o1 instanceof User \u0026\u0026 o2 instanceof User){ User u1 = (User) o1; User u2 = (User) o2; return Integer.compare(u1.getAge(),u2.getAge()); }else{ throw new RuntimeException(\"传入的类型不匹配\"); } } }); map.put(new User(\"Tom\",23),98); map.put(new User(\"Jerry\",32),89); map.put(new User(\"Jack\",20),76); map.put(new User(\"Rose\",18),100); Set set = map.entrySet(); for (Object o : set) { Map.Entry entry = (Map.Entry) o; System.out.println(entry.getKey() + \"-\u003e\" + entry.getValue()); } Properties类(处理属性文件)： 1 2 3 4 5 6 7 Properties prop = new Properties(); FileInputStream fis = new FileInputStream(\"jdbc.properties\");\t//字节输入流，IO流 //传入的文件名，文件的相对路径，相对于当前的工程 prop.load(fis);\t//加载流对应的文件 String name = prop.getProperty(\"name\"); String password = prop.getProperty(\"password\"); System.out.println(name + \"-\u003e\" + password); 泛型： 1. 集合或接口在jdk5.0时都修改为带泛型的结构。 2. 在实例化集合时，可以指明具体的泛型类型。 3. 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构(方法，构造器，属性等)，使用到泛型类的位置，都指定为实例化时的泛型类型。 4. 泛型的类型必须是类，不能是基本数据类型，需要用到基本数据类型的位置，拿包装类替换。 5. 如果实例化时，没有指明泛型类型，默认类型为java.lang.Object类型。 在集合中使用泛型之前的情况： 1 2 3 4 5 6 7 8 9 10 List list = new ArrayList();\t//要求：存放学生成绩 list.add(78); list.add(76); list.add(89); list.add(88); list.add(\"Tom\");\t//问题一：类型不安全 for (Object o : list) { int score = (int) o;\t//问题二：强转时，可能出现ClassCastException System.out.println(score); } 在集合中使用泛型的情况： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(78); list.add(76); list.add(89); list.add(88); list.add(\"Tom\");\t//编译时会进行类型检查，保证数据的安全 for (Integer integer : list) { System.out.println(integer);\t//避免了强转操作 } Iterator\u003cInteger\u003e iterator = list.iterator(); while(iterator.hasNext()){ Integer next = iterator.next(); System.out.println(next); } 集合带有泛型(键值对)的情况： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 TreeMap\u003cUser,Integer\u003e map = new TreeMap\u003c\u003e(new Comparator\u003cUser\u003e() { @Override public int compare(User o1, User o2) { return Integer.compare(o1.getAge(),o2.getAge()); } }); map.put(new User(\"Tom\",23),98); map.put(new User(\"Jerry\",32),89); map.put(new User(\"Jack\",20),76); map.put(new User(\"Rose\",18),100); Set\u003cMap.Entry\u003cUser, Integer\u003e\u003e entries = map.entrySet(); for (Map.Entry\u003cUser, Integer\u003e entry : entries) { System.out.println(entry.getKey() + \"-\u003e\" + entry.getValue()); } Map\u003cString,String\u003e map = new HashMap\u003c\u003e(); map.put(\"K\",\"V\"); 自定义泛型类： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Order\u003cT\u003e { String orderName; int orderId; T orderT;\t//类的内部结构就可以使用类的泛型 public Order() {} public T getOrderT() { return orderT; } public void setOrderT(T orderT) { this.orderT = orderT; } public Order(String orderName, int orderId, T orderT) { this.orderName = orderName; this.orderId = orderId; this.orderT = orderT; } @Override public String toString() { return \"Order{\" + \"orderName='\" + orderName + '\\'' + \", orderId=\" + orderId + \", orderT=\" + orderT + '}'; } } 测试自定义的泛型类： 1 2 3 4 5 6 7 //如果定义了泛型类，实例化时没有指明类的泛型，则认为此泛型类为Object Order order = new Order();\torder.orderT = 123; order.orderT = \"ABC\"; //实例化时指明类的泛型 Order\u003cString\u003e order1 = new Order\u003c\u003e(\"orderAA\",1001,\"AA\");\torder1.orderT = \"AA:Hello\"; 子类的泛型类： 1 2 3 4 5 SubOrder1\u003cString\u003e subOrder1 = new SubOrder1\u003c\u003e();\t//子类保留父类的泛型 subOrder1.orderT = \"1001\"; SubOrder subOrder = new SubOrder(); //由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型 subOrder.orderT = 1001; 泛型方法： 在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系，换句话说，泛型方法所属的类是不是泛型类都没有关系，泛型方法可以声明为静态的，泛型参数在调用方法时确定的，和类的实例化没关系。 1 2 3 4 5 6 7 8 9 10 11 List\u003cInteger\u003e list = copyFromArrayList(new Integer[]{1, 2, 3, 4}); for (Integer integer : list) { System.out.println(integer); } public \u003cE\u003e List\u003cE\u003e copyFromArrayList(E[] arr){ ArrayList\u003cE\u003e list = new ArrayList\u003c\u003e(); for (E e : list) { list.add(e); } return list; } 子父类的泛型： 1 2 3 4 5 6 7 8 9 10 11 12 List\u003cString\u003e list1 = null; ArrayList\u003cString\u003e list2 = null; list1 = list2;\t//编译通过 Object obj = null; String str = null; obj = str; Object [] arr1 = null; String [] arr2 = null; arr1 = arr2; List\u003cObject\u003e list1 = null; List\u003cString\u003e list2 = null; list1 = list2;\t//编译不通过，此时的list1和list2不具备子父类关系 通配符：? 类A是类B的父类，G和G是没有关系的，二者共同的父类是G\u003c?\u003e。 1 2 3 4 5 6 7 8 9 10 11 12 13 List\u003cObject\u003e list1 = null; List\u003cString\u003e list2 = null; List\u003c?\u003e list = null; list = list1; list = list2; List\u003cString\u003e list3 = new ArrayList\u003c\u003e(); list3.add(\"AA\"); list3.add(\"BB\"); list3.add(\"CC\"); list = list3;\t//对于List\u003c?\u003e不能向其内部添加数据 list.add(\"DD\"); list.add(null);\t//除了添加null System.out.println(list.get(1)); 有限制的通配符： G\u003c? extends A\u003e可以作为G和G的父类，其中B是A的子类。 G\u003c? super A\u003e可以作为G和G的父类，其中B是A的父类。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 List\u003c? extends Person\u003e list1 = null; List\u003c? super Person\u003e list2 = null; List\u003cStudent\u003e list3 = null; List\u003cPerson\u003e list4 = null; List\u003cObject\u003e list5 = null; list1 = list3; list1 = list4; list1 = list5; list2 = list3; list2 = list4; list2 = list5; list1 = list4; Person person = list1.get(0); Student student = list1.get(0); list2 = list4; Object object = list2.get(0); Person person1 = list2.get(0); list1.add(new Student()); list2.add(new Person()); list2.add(new Student()); 子类不保留父类的泛型： 1 2 3 4 5 6 7 8 9 10 class Father\u003cT1,T2\u003e{}\tclass Son1 extends Father{}\t//等价于class Son1 extends Father\u003cObject,Object\u003e //没有类型，擦除 class Son2 extends Father\u003cInteger,String\u003e{} //具体类型 class Son3\u003cT1,T2\u003e extends Father\u003cT1,T2\u003e{} //子类保留父类的泛型(全部保留) class Son4\u003cT2\u003e extends Father\u003cInteger,T2\u003e{} //子类保留父类的泛型(部分保留) public class Gen {} File类： File类的一个对象，代表一个文件或一个文件夹。 File类声明在java.io包下。 如何创建一个File类的对象： File(String filePath) File(String parentPath,String childPath) File(File parentFile,String childPath) 相对路径：相较于某个路径下，指明的路径。 绝对路径：包含盘符在内的文件目录的路径。 路径分隔符：“windows：\\\"，“UNIX：/\"。 File类的构造器： 1 2 3 4 5 6 7 8 File file1 = new File(\"hello.txt\");\t//构造器1 File file2 = new File(\"E:\\\\hello.txt\");\t//绝对路径 System.out.println(file1); System.out.println(file2); File file3 = new File(\"e:\\\\app\",\"log\");\t//构造器2 System.out.println(file3); File file4 = new File(file3,\"hello.txt\");\t//构造器3 System.out.println(file4); File类的一些方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 File file1 = new File(\"hello.txt\"); File file2 = new File(\"D:\\\\io\\\\hi.txt\"); System.out.println(\"file1的绝对路径：\" + file1.getAbsolutePath()); System.out.println(\"file1的路径：\" + file1.getPath()); System.out.println(\"file1的文件名：\" + file1.getName()); System.out.println(\"file1的上级目录：\" + file1.getParent()); System.out.println(\"file1的文件大小：\" + file1.length() + \"字节\"); System.out.println(\"file1的最后一次修改时间：\" + new Date(file1.lastModified())); System.out.println(\"------------------------------------------------\"); System.out.println(\"file2的绝对路径：\" + file2.getAbsolutePath()); System.out.println(\"file2的路径：\" + file2.getPath()); System.out.println(\"file2的文件名：\" + file2.getName()); System.out.println(\"file2的上级目录：\" + file2.getParent()); System.out.println(\"file2的文件大小：\" + file2.length() + \"字节\"); System.out.println(\"file2的最后一次修改时间：\" + new Date(file2.lastModified())); File类的一些方法： 1 2 3 4 5 6 7 8 9 10 File file = new File(\"E:\\\\workspace\\\\lggd2_idea\\\\JavaSenior\"); String[] list = file.list();\t//获取指定目录下的所有文件名 for (String s : list) { System.out.println(s); } System.out.println(\"-----------------------------------------------\"); File[] files = file.listFiles();\t//获取指定目录下的所有文件对象 for (File file1 : files) { System.out.println(file1); } File类的一些方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 File file = new File(\"E:\\\\workspace\\\\lggd2_idea\\\\JavaSenior\"); String[] list = file.list(new FilenameFilter() { @Override public boolean accept(File dir, String name) { if(name.endsWith(\".properties\")){ return true; } return false; } }); for (String s : list) { System.out.println(s); } File类的一些方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 File file = new File(\"E:\\\\workspace\\\\lggd2_idea\\\\JavaSenior\"); File[] files = file.listFiles(new FileFilter() { @Override public boolean accept(File pathname) { if(!pathname.isDirectory()){ return true; } return false; } }); for (File file1 : files) { System.out.println(file1); } File类的一些方法： 1 2 3 4 5 File file1 = new File(\"hello.txt\"); File file2 = new File(\"haha.txt\"); boolean b = file1.renameTo(file2);\t//要想保证返回true，需要file1在硬盘中是存在的，且file2在指定的目录中不存在 System.out.println(b); File类的一些方法： 1 2 3 4 5 6 7 File file = new File(\"haha.txt\"); System.out.println(\"file是否是目录：\" + file.isDirectory()); System.out.println(\"file是否是文件：\" + file.isFile()); System.out.println(\"file是否存在：\" + file.exists()); System.out.println(\"file是否可读：\" + file.canRead()); System.out.println(\"file是否可写：\" + file.canWrite()); System.out.println(\"file是否是隐藏文件：\" + file.isHidden()); 文件的创建： 1 2 3 4 5 6 7 8 File file = new File(\"hello.txt\"); if(!file.exists()){ file.createNewFile(); System.out.println(\"创建成功\"); }else{ file.delete();\t//Java中的删除时不走回收站，删除无法撤回 System.out.println(\"删除成功\"); } 文件目录的创建： 1 2 3 4 5 File file = new File(\"d:\\\\io\"); boolean mkdir = file.mkdir(); if(mkdir){ System.out.println(\"创建成功\"); } 文件目录的创建： 1 2 3 4 5 File file = new File(\"d:\\\\io\\\\file\"); boolean mkdirs = file.mkdirs(); if(mkdirs){ System.out.println(\"创建成功\"); } 文件的创建： 1 2 File file = new File(\"d:\\\\io\\\\hello.txt\"); System.out.println(file.delete());\t//Java中只能删除空目录 可以统一使用”/\"。 File类中提供了路径分隔符的常量。 File类中涉及到文件或文件目录的创建、删除、重命名、各种查询，没有向文件内部写入数据或读取数据的方法。 用IO流读取或写入数据。 File类就会作为参数传递到流的内部，指明读取或写入的终点。 File类的一些方法： 1 2 3 4 File file = new File(\"d:\" + File.separator + \"io\" + File.separator + \"hello\"); System.out.println(file.delete()); System.out.println(File.separator); System.out.println(File.pathSeparator); IO流： 1. 流的分类： 按操作数据单位不同分为：字节流，字符流。 按照数据流的流向不同分为：输入流、输出流。 按流的角色不同分为：节点流、处理流。 2. 流的体系结构： 抽象基类：InputStream，OutputStream，Reader,Writer 节点流：FileInputStream,FileOutputStream,FileReader,FileWriter 缓冲流(处理流的一种)： BufferedInputStream，BufferedOutputStream，BufferdReader，BufferedWirter。 抽象基类： 输入流：InputStream(字节输入流)，Reader(字符输入流)。 输出流：OutputStream(字节输出流)，Writer(字符输出流)。 Java的IO流共涉及40多个类，从如上4个抽象基类派生的。 字符输入流： 1. read()：返回读入的一个字符，如果达到末尾，返回-1。 2. 异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try…catch..finally处理。 3. 读入的文件一定要存在，否则会报FileNotFoundException。 File类操作文件对象： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 File file = new File(\"hello.txt\");\t//1. 实例化File对象，指明要操作的文件 FileReader fr = null; try { fr = new FileReader(file);\t//2. 提供具体的流 //3. 数据的读入：read()：返回读入的一个字符。如果达到文件末尾，返回-1 //方式1： int data = fr.read(); while(data != -1){ System.out.print((char)data); data = fr.read(); } //方式2： int data; while((data = fr.read())!= -1){ System.out.print((char)data); } } catch (Exception e) { e.printStackTrace(); } finally { if(fr != null){\t//4. 流的关闭 try { fr.close(); } catch (IOException e) { e.printStackTrace(); } } } File类操作文件对象： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 File file = new File(\"hello.txt\");\t//1. File类的实例化 FileReader fr = null;\t//2. FileReader的实例化 try { fr = new FileReader(file); //3. 读入的操作：read(char [] cbuf)返回每次读入的cbuf数组中的字符个数，如果达到文件末尾，返回-1 char [] cbuf = new char[5]; int len; while((len = fr.read(cbuf)) != -1){ System.out.println(new String(cbuf, 0, len)); } } catch (Exception e) { e.printStackTrace(); } finally { if(fr != null){ try { fr.close(); } catch (IOException e) { e.printStackTrace(); } } } 字符输出流： 1. 输出操作，对应的File可以不存在的，并不会报异常。 2. File类对应的文件如果不存在，则会自动创建文件。如果存在，并且如果调用的构造器是FileWriter(file,false)或 FileWriter(file)则对源文件覆盖，如果调用的构造器是FileWriter(file,true)，则不会覆盖，而是会在原有基础上追加内容。 File类操作文件对象： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 File file = new File(\"hi.txt\");\t//1. 提供File类对象，指明写出文件 FileWriter fw = null;\t//2. 提供FileWriter对象 try { fw = new FileWriter(file,true); fw.write(\"I'm fine,Thank You.And you?\\n\");\t//3. 写出的操作 fw.write(\"I'm fine too\"); System.out.println(\"数据写入成功\"); } catch (Exception e) { e.printStackTrace(); } finally { if(fw != null){ try { fw.close(); } catch (IOException e) { e.printStackTrace(); } } } 文件的复制： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 File srcFile = new File(\"hello.txt\");\t//1. 创建File类的对象，指明读入和写出的文件 File destFile = new File(\"D:\\\\io\\\\hello.txt\"); FileReader fr = null;\t//2. 创建流的对象 FileWriter fw = null; try { fr = new FileReader(srcFile);\t//3. 数据的读入和写出操作 fw = new FileWriter(destFile); char [] cbuf = new char[5]; int len; while((len = fr.read(cbuf))!=-1){ fw.write(cbuf,0,len); } System.out.println(\"文件复制成功...\"); } catch (Exception e) { e.printStackTrace(); }finally { if(fw != null){\t//4. 关闭流，先开的后关，后开的先关 try { fw.close(); } catch (IOException e) { e.printStackTrace(); } } if(fr != null){ try { fr.close(); } catch (IOException e) { e.printStackTrace(); } } } 字节输入流： 1. 对于文本文件（.txt,.java,.c,.c++,.cpp），使用字符流处理。 2. 对于非文本文件（.jpg,.mp3,.mp4,.docx,.ppx,…），使用字节流处理。 3. 使用字节流处理文本文件容易出现乱码。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 File file = new File(\"hello.txt\"); FileInputStream fis = null; try { fis = new FileInputStream(file); byte [] buffer = new byte[1024]; int len; while((len = fis.read(buffer)) != -1){ String str = new String(buffer,0,len); System.out.print(str); for (byte b : buffer) { System.out.print(b); } } } catch (Exception e) { e.printStackTrace(); } finally{ if(fis != null){ try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } } 文件的复制： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 File srcFile = new File(\"123.jpg\"); File destFile = new File(\"456.jpg\"); FileInputStream fis = null; FileOutputStream fos = null; try { fis = new FileInputStream(srcFile); fos = new FileOutputStream(destFile); byte [] buffer = new byte[1024]; int len; while((len = fis.read(buffer)) != -1){ fos.write(buffer,0,len); } System.out.println(\"文件复制成功\"); } catch (Exception e) { e.printStackTrace(); } finally{ if(fos != null){ try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } if(fis != null){ try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } } 缓冲字节流(文件的的复制)： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 File srcFile = new File(\"123.jpg\"); File destFile = new File(\"1231.jpg\"); FileInputStream fis = null;\t//造节点流 FileOutputStream fos = null; BufferedInputStream bis = null;\t//造处理流 BufferedOutputStream bos = null; try { fis = new FileInputStream(srcFile); fos = new FileOutputStream(destFile); bis = new BufferedInputStream(fis); bos = new BufferedOutputStream(fos); byte[] buffer = new byte[10]; int len; while((len = bis.read(buffer)) != -1){ bos.write(buffer,0,len); bos.flush();\t//刷新缓冲区 } System.out.println(\"复制成功\"); } catch (Exception e) { e.printStackTrace(); } finally{ if(bos != null){ try { bos.close(); } catch (IOException e) { e.printStackTrace(); } } if(bis != null){ try { bis.close(); } catch (IOException e) { e.printStackTrace(); } } } 缓冲字符流(文本文件的复制)： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 BufferedReader br = null; BufferedWriter bw = null; try { br = new BufferedReader(new FileReader(\"hello.txt\")); bw = new BufferedWriter(new FileWriter(\"hello2.txt\")); char [] cbuf = new char[1024]; int len; while((len = br.read(cbuf)) != -1){ bw.write(cbuf,0,len); bw.flush(); } System.out.println(\"复制成功\"); } catch (Exception e) { e.printStackTrace(); } finally { if(bw != null){ try { bw.close(); } catch (IOException e) { e.printStackTrace(); } } if(br != null){ try { br.close(); } catch (IOException e) { e.printStackTrace(); } } } 缓冲字符流(文本文件的复制)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 BufferedReader br = null; BufferedWriter bw = null; try { br = new BufferedReader(new FileReader(\"hello.txt\")); bw = new BufferedWriter(new FileWriter(\"hello3.txt\")); String data; while((data = br.readLine()) != null){ bw.write(data + \"\\n\"); bw.newLine(); } System.out.println(\"复制成功\"); } catch (Exception e) { e.printStackTrace(); } finally { if(bw != null){ try { bw.close(); } catch (IOException e) { e.printStackTrace(); } } if(br != null){ try { br.close(); } catch (IOException e) { e.printStackTrace(); } } } 处理流，缓冲流，提高流的读取、写入速度，是套接在已有流的基础上。 序列化：用ObjectOutputStream类保存基本类型数据或对象的机制。 反序列化：用ObjectInputStream类读取基本类型数据或对象的机制。 序列化与反序列化的要求：目标类需要实现接口，Serializable，生成一个序列号。 ObjectOutputStream类操作文件： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ObjectOutputStream oos = null; try { oos = new ObjectOutputStream(new FileOutputStream(\"object.dat\")); oos.writeObject(new String(\"我爱长春\")); oos.flush(); System.out.println(\"写出数据成功\"); } catch (Exception e) { e.printStackTrace(); } finally{ if(oos != null){ try { oos.close(); } catch (IOException e) { e.printStackTrace(); } } } ObjectInputStream类操作文件： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ObjectInputStream ois = null; try { ois = new ObjectInputStream(new FileInputStream(\"object.dat\")); String s = (String) ois.readObject(); System.out.println(s); } catch (Exception e) { e.printStackTrace(); } finally{ if(ois != null){ try { ois.close(); } catch (IOException e) { e.printStackTrace(); } } } ObjectOutputStream类操作文件： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ObjectOutputStream oos = null; try { oos = new ObjectOutputStream(new FileOutputStream(\"person.dat\")); oos.writeObject(new Person(\"张三\",30)); oos.flush(); System.out.println(\"写出数据成功\"); } catch (Exception e) { e.printStackTrace(); } finally{ if(oos != null){ try { oos.close(); } catch (IOException e) { e.printStackTrace(); } } } ObjectInputStream类操作文件： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ObjectInputStream ois = null; try { ois = new ObjectInputStream(new FileInputStream(\"person.dat\")); Person p = (Person) ois.readObject(); System.out.println(p); } catch (Exception e) { e.printStackTrace(); } finally{ if(ois != null){ try { ois.close(); } catch (IOException e) { e.printStackTrace(); } } } 序列码(第一序列化时)： private static final long serialVersionUID = 147258369L; 反射： Reflection动态语言的关键。 java.lang.Class:代表一个类。 java.lang.reflect.Method：代表类的方法。 java.lang.reflect.Field；代表类的成员变量。 java.lang.reflect.Constructor：代表类的构造器。 通过直接new的方式或反射的方式都可以调用公共结构，开发中用哪个？建议用new。 反射机制与面向对象中的封装性是不是矛盾的？不矛盾。 反射前，对于Person类的相应操作： 1 2 3 4 5 Person p1 = new Person(\"Tom\",12);\t//创建Person类的对象 p1.age = 10;\t//通过对象，调用其内部的属性，方法 System.out.println(p1); //在Person类的外部，不能通过Person类的对象调其内部的私有结构，如name()、showNation()及私有的构造器等 p1.show(); 反射： 1 2 3 4 5 6 7 8 9 Class\u003cPerson\u003e clazz = Person.class;\t//通过反射，创建Person类对象 Constructor\u003cPerson\u003e cons = clazz.getConstructor(String.class, int.class); Person p = cons.newInstance(\"Tom\", 12); System.out.println(p); Field age = clazz.getDeclaredField(\"age\");\t//通过反射，调用对象指定的属性 age.set(p,10); System.out.println(p); Method show = clazz.getDeclaredMethod(\"show\");\t//通过反射，调用对象指定的方法 show.invoke(p); 反射： 1 2 3 4 5 6 7 8 9 10 11 12 Class\u003cPerson\u003e clazz = Person.class; Constructor\u003cPerson\u003e cons = clazz.getConstructor(String.class); Person person = cons.newInstance(\"Jerry\"); System.out.println(person); Field name = clazz.getDeclaredField(\"name\");\t//调用私有属性 name.setAccessible(true);\t//设置私有化属性可以被访问 name.set(person,\"Hanmeimei\"); System.out.println(person); Method showNation = clazz.getDeclaredMethod(\"showNation\", String.class);//调用私有方法 showNation.setAccessible(true); String nation = (String) showNation.invoke(person, \"中国\"); System.out.println(nation); java.lang.Class类： 1. 类的加载过程：程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class)，接着我们使用java.exe对某个字节码文件进行解释运行。相当于将字节码文件加载到内存中，此过程就称为类的加载过程，加载到内存中的类，我们称为运行时类：Class clazz = Person.class; 2. Class的实例对应着一个运行时类。 3. 加载到内存中的运行时类，会缓存一定的时间，在此时间之内，可以通过不同的方式来获取此运行时类。 获取运行时类的方式(Class类的实例)： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Class\u003cPerson\u003e clazz1 = Person.class;\t//方式1：调用运行时类的属性.class System.out.println(clazz1); Person p1 = new Person(); Class\u003c? extends Person\u003e clazz2 = p1.getClass();\t//方式2：通过运行时类的对象，调用getClass() System.out.println(clazz2); Class\u003c?\u003e clazz3 = Class.forName(\"com.crx.java.Person\");\t//方式3：调用Class类的静态方法 System.out.println(clazz3); ClassLoader classLoader = Ch02.class.getClassLoader();\tClass\u003c?\u003e clazz4 = classLoader.loadClass(\"com.crx.java.Person\"); //方式4：使用类的加载器ClassLoader(了解) System.out.println(clazz4); System.out.println(clazz1 == clazz2); System.out.println(clazz2 == clazz3); System.out.println(clazz1 == clazz4); 类的加载器： 1 2 3 4 5 6 7 ClassLoader classLoader = Ch03.class.getClassLoader();\t//对于自定义类，使用系统类加载器进行加载 System.out.println(classLoader); ClassLoader classLoader1 = classLoader.getParent();\t//调用系统类加载器的getParent() System.out.println(classLoader1); //调用扩展类加载器的getParent()，无法再获取引导类的加载器 ClassLoader classLoader2 = classLoader1.getParent();\tSystem.out.println(classLoader2); 加载配置文件： 1 2 3 4 5 6 7 8 9 Properties prop = new Properties(); //读取配置文件的方式2：用ClassLoader ClassLoader classLoader = Ch04.class.getClassLoader();\t//配置文件的相对路径默认识别为：当前module的src下 InputStream is = classLoader.getResourceAsStream(\"jdbc1.properties\"); prop.load(is); String user = prop.getProperty(\"user\"); String password = prop.getProperty(\"password\"); System.out.println(user + \":\" + password); 反射的动态性： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public Object getInstance(String classPath) throws ClassNotFoundException, IllegalAccessException, InstantiationException { Class\u003c?\u003e clazz = Class.forName(classPath);//创建一个指定类的对象，classPath：指定类的全类名 return clazz.newInstance();\t} public void test() throws IllegalAccessException, InstantiationException, ClassNotFoundException { int number = 2; String classPath = \"\"; switch(number){ case 0: classPath = \"com.crx.java.Person\"; break; case 1: classPath = \"java.sql.Date\"; break; case 2: classPath = \"java.util.Date\"; break; } Object instance = getInstance(classPath); System.out.println(instance); } 可以有Class类对象的类型： class，interface，数组，枚举，注解类型，基本数据类型，void。 1 2 3 4 5 6 7 8 9 Class\u003cObject\u003e c1 = Object.class; Class\u003cComparable\u003e c2 = Comparable.class; Class\u003cString[]\u003e c3 = String[].class; Class\u003cint[][]\u003e c4 = int[][].class; Class\u003cElementType\u003e c5 = ElementType.class; Class\u003cOverride\u003e c6 = Override.class; Class\u003cInteger\u003e c7 = int.class; Class\u003cVoid\u003e c8 = void.class; Class\u003cClass\u003e c9 = Class.class; 反射： 1 2 3 4 5 6 7 8 9 10 11 12 Class\u003cPerson\u003e clazz = Person.class; //getFields()：获取当前运行时类及其所有父类中声明为public访问权限的属性 Field[] fields = clazz.getFields(); for (Field field : fields) { System.out.println(field); } System.out.println(\"--------------------------\"); //getDeclaredFields()：获取当前运行时类中的所有属性(不包含父类中的属性) Field[] declaredFields = clazz.getDeclaredFields(); for (Field declaredField : declaredFields) { System.out.println(declaredField); } 反射： 1 2 3 4 5 6 7 8 9 10 11 Class\u003cPerson\u003e clazz = Person.class; Field[] declaredFields = clazz.getDeclaredFields(); for (Field f : declaredFields) { int modifiers = f.getModifiers();\t//权限修饰符 System.out.print(Modifier.toString(modifiers) + \" \"); Class\u003c?\u003e type = f.getType();\t//数据类型 System.out.print(type + \" \"); String name = f.getName();\t//变量名 System.out.print(name); System.out.println(); } 反射： 1 2 3 4 5 6 7 8 9 10 11 12 Class\u003cPerson\u003e clazz = Person.class; //获取当前运行时类及其父类所有声明为public权限的方法 Method[] methods = clazz.getMethods(); for (Method method : methods) { System.out.println(method); } System.out.println(\"--------------------\"); //获取当前运行时类中声明的所有方法(不包含父类中声明的方法) Method[] declaredMethods = clazz.getDeclaredMethods(); for (Method method : declaredMethods) { System.out.println(method); } 反射： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Class\u003cPerson\u003e clazz = Person.class; Method[] declaredMethods = clazz.getDeclaredMethods(); for (Method m : declaredMethods) { Annotation[] annos = m.getAnnotations();\t//获取方法声明的注解 for (Annotation anno : annos) { System.out.println(anno); } System.out.println(Modifier.toString(m.getModifiers()));\t//权限修饰符 System.out.println(m.getReturnType());\t//返回值类型 System.out.println(m.getName());\t//方法名 Class\u003c?\u003e[] types = m.getParameterTypes();\t//形参列表 if(types != null \u0026\u0026 types.length != 0){ for (int i = 0; i \u003c types.length; i++) { System.out.println(types[i].getName() + \" args_\" + i); } } Class\u003c?\u003e[] exceptionTypes = m.getExceptionTypes();\t//抛出的异常 if(exceptionTypes != null \u0026\u0026 exceptionTypes.length != 0){ for (Class\u003c?\u003e exceptionType : exceptionTypes) { System.out.println(exceptionType.getName()); } } } 反射： 1 2 3 4 5 6 7 8 9 10 11 Class\u003cPerson\u003e clazz = Person.class; //获取当前运行时类中声明为public的构造器 Constructor\u003c?\u003e[] constructors = clazz.getConstructors();\tfor (Constructor\u003c?\u003e constructor : constructors) { System.out.println(constructor); } //获取当前运行时类中的所有构造器 Constructor\u003c?\u003e[] declaredConstructors = clazz.getDeclaredConstructors(); for (Constructor\u003c?\u003e declaredConstructor : declaredConstructors) { System.out.println(declaredConstructor); } 反射： 1 2 3 Class\u003cPerson\u003e clazz = Person.class; Constructor\u003c?\u003e[] declaredConstructors = clazz.getDeclaredConstructors(); for (Constructor\u003c?\u003e d : declaredConstructors) {} 获取运行时类声明的注解： 1 2 3 4 5 Class\u003cPerson\u003e clazz = Person.class; Annotation[] annotations = clazz.getAnnotations(); for (Annotation a : annotations) { System.out.println(a); } 获取运行时类所在的包： 1 2 3 Class\u003cPerson\u003e clazz = Person.class; Package p = clazz.getPackage(); System.out.println(p); 获取运行时类实现的接口： 1 2 3 4 5 6 Class\u003cPerson\u003e clazz = Person.class; //获取运行时类实现的接口，不包括父类实现的接口 Class\u003c?\u003e[] interfaces = clazz.getInterfaces();\tfor (Class\u003c?\u003e anInterface : interfaces) { System.out.println(anInterface); } 获取运行时类的带泛型父类的泛型： 1 2 3 4 5 6 7 Class\u003cPerson\u003e clazz = Person.class; Type genericSuperclass = clazz.getGenericSuperclass(); ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass; Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\t//获取泛型类型 for (Type actualTypeArgument : actualTypeArguments) { System.out.println(actualTypeArgument); } 获取运行时带泛型的父类： 1 2 3 Class\u003cPerson\u003e clazz = Person.class; Type genericSuperclass = clazz.getGenericSuperclass(); System.out.println(genericSuperclass); 获取运行时类的父类： 1 2 3 Class\u003cPerson\u003e clazz = Person.class; Class\u003c? super Person\u003e superclass = clazz.getSuperclass(); System.out.println(superclass); 调用运行时类中的指定属性： 1 2 3 4 5 Class\u003cPerson\u003e clazz = Person.class; Person p = clazz.newInstance();\t//创建运行时类的对象 Field id = clazz.getField(\"id\");\t//只能获取public类型的属性 id.set(p,1001); System.out.println(id.get(p)); 反射和泛型： 1 2 3 4 5 6 Class\u003cPerson\u003e clazz = Person.class; Person p = clazz.newInstance();\t//创建运行时类的对象 Field name = clazz.getDeclaredField(\"name\");\t//获取运行时类中指定变量名的属性 name.setAccessible(true); name.set(p,\"Tom\"); System.out.println(name.get(p)); 反射和泛型： 1 2 3 4 5 6 7 8 9 10 Class\u003cPerson\u003e clazz = Person.class; Person p = clazz.newInstance();\t//创建运行时类的对象 Method show = clazz.getDeclaredMethod(\"show\", String.class); show.setAccessible(true); String nation = (String) show.invoke(p,\"中国\"); System.out.println(nation); System.out.println(\"*****************\"); Method showDest = clazz.getDeclaredMethod(\"showDest\"); showDest.setAccessible(true); showDest.invoke(Person.class); 反射和泛型： 1 2 3 4 5 Class\u003cPerson\u003e clazz = Person.class; Constructor\u003cPerson\u003e declaredConstructor = clazz.getDeclaredConstructor(String.class); declaredConstructor.setAccessible(true); Person person = declaredConstructor.newInstance(\"Tom\"); System.out.println(person); 泛型(父类)： 1 2 3 4 5 6 7 8 9 10 public class Creature\u003cT\u003e implements Serializable { private char gender; public double weight; private void breath(){ System.out.println(\"生物呼吸\"); } public void eat(){ System.out.println(\"生物吃东西\"); } } 自定义注解： 1 2 3 4 5 @Target({ElementType.TYPE, ElementType.FIELD,ElementType.METHOD,ElementType.PARAMETER,ElementType.CONSTRUCTOR,ElementType.LOCAL_VARIABLE}) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotation { String value() default \"hello\"; } 实现接口： 1 public interface MyInterface { void info(); } 实现类： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @MyAnnotation(value = \"hi\") public class Person extends Creature\u003cString\u003e implements Comparable\u003cString\u003e,MyInterface { private String name; int age; public int id; public Person() {} @MyAnnotation(value = \"abc\") private Person(String name) { this.name = name; } @MyAnnotation Person(String name, int age) { this.name = name; this.age = age; } @MyAnnotation private String show(String nation){ return nation; } public String display(String interests){ return interests; } @Override public void info() throws RuntimeException { System.out.println(\"我是一个人\"); } @Override public int compareTo(String o) { return 0; } private static void showDest(){ System.out.println(\"haha\"); } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", id=\" + id + '}'; } } 反射和泛型： 1 2 3 4 5 6 7 8 9 10 11 12 Class\u003cPerson\u003e clazz = Person.class; //getFields()：获取当前运行时类及其所有父类中声明为public访问权限的属性 Field[] fields = clazz.getFields(); for (Field field : fields) { System.out.println(field); } System.out.println(\"--------------------------\"); //getDeclaredFields()：获取当前运行时类中的所有属性(不包含父类中的属性) Field[] declaredFields = clazz.getDeclaredFields(); for (Field declaredField : declaredFields) { System.out.println(declaredField); } 反射和泛型： 1 2 3 4 5 6 7 8 9 10 11 Class\u003cPerson\u003e clazz = Person.class; Field[] declaredFields = clazz.getDeclaredFields(); for (Field f : declaredFields) { int modifiers = f.getModifiers();\t//权限修饰符 System.out.print(Modifier.toString(modifiers) + \" \"); Class\u003c?\u003e type = f.getType();\t//数据类型 System.out.print(type + \" \"); String name = f.getName();\t//变量名 System.out.print(name); System.out.println(); } 反射和泛型： 1 2 3 4 5 6 7 8 9 10 11 12 Class\u003cPerson\u003e clazz = Person.class; //获取当前运行时类及其父类所有声明为public权限的方法 Method[] methods = clazz.getMethods();\tfor (Method method : methods) { System.out.println(method); } System.out.println(\"--------------------\"); //获取当前运行时类中声明的所有方法(不包含父类中声明的方法) Method[] declaredMethods = clazz.getDeclaredMethods(); for (Method method : declaredMethods) { System.out.println(method); } 反射和泛型： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Class\u003cPerson\u003e clazz = Person.class; Method[] declaredMethods = clazz.getDeclaredMethods(); for (Method m : declaredMethods) { Annotation[] annos = m.getAnnotations();\t//获取方法声明的注解 for (Annotation anno : annos) { System.out.println(anno); } System.out.println(Modifier.toString(m.getModifiers()));\t//权限修饰符 System.out.println(m.getReturnType());\t//返回值类型 System.out.println(m.getName());\t//方法名 Class\u003c?\u003e[] types = m.getParameterTypes();\t//形参列表 if(types != null \u0026\u0026 types.length != 0){ for (int i = 0; i \u003c types.length; i++) { System.out.println(types[i].getName() + \" args_\" + i); } } Class\u003c?\u003e[] exceptionTypes = m.getExceptionTypes();\t//抛出的异常 if(exceptionTypes != null \u0026\u0026 exceptionTypes.length != 0){ for (Class\u003c?\u003e exceptionType : exceptionTypes) { System.out.println(exceptionType.getName()); } } } 反射和泛型： 1 2 3 4 5 6 7 8 9 10 11 Class\u003cPerson\u003e clazz = Person.class; //获取当前运行时类中声明为public的构造器 Constructor\u003c?\u003e[] constructors = clazz.getConstructors(); for (Constructor\u003c?\u003e constructor : constructors) { System.out.println(constructor); } //获取当前运行时类中的所有构造器 Constructor\u003c?\u003e[] declaredConstructors = clazz.getDeclaredConstructors(); for (Constructor\u003c?\u003e declaredConstructor : declaredConstructors) { System.out.println(declaredConstructor); } 反射和泛型： 1 2 3 Class\u003cPerson\u003e clazz = Person.class; Constructor\u003c?\u003e[] declaredConstructors = clazz.getDeclaredConstructors(); for (Constructor\u003c?\u003e d : declaredConstructors) {} 获取运行时类的父类： 1 2 3 Class\u003cPerson\u003e clazz = Person.class; Class\u003c? super Person\u003e superclass = clazz.getSuperclass(); System.out.println(superclass); 获取运行时带泛型的父类： 1 2 3 Class\u003cPerson\u003e clazz = Person.class; Type genericSuperclass = clazz.getGenericSuperclass(); System.out.println(genericSuperclass); 获取运行时类的带泛型父类的泛型： 1 2 3 4 5 6 7 Class\u003cPerson\u003e clazz = Person.class; Type genericSuperclass = clazz.getGenericSuperclass(); ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass; Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\t//获取泛型类型 for (Type actualTypeArgument : actualTypeArguments) { System.out.println(actualTypeArgument); } 获取运行时类实现的接口： 1 2 3 4 5 6 Class\u003cPerson\u003e clazz = Person.class; //获取运行时类实现的接口，不包括父类实现的接口 Class\u003c?\u003e[] interfaces = clazz.getInterfaces(); for (Class\u003c?\u003e anInterface : interfaces) { System.out.println(anInterface); } 获取运行时类所在的包： 1 2 3 Class\u003cPerson\u003e clazz = Person.class; Package p = clazz.getPackage(); System.out.println(p); 获取运行时类声明的注解： 1 2 3 4 5 Class\u003cPerson\u003e clazz = Person.class; Annotation[] annotations = clazz.getAnnotations(); for (Annotation a : annotations) { System.out.println(a); } 调用运行时类中的指定属性： 1 2 3 4 5 Class\u003cPerson\u003e clazz = Person.class; Person p = clazz.newInstance();\t//创建运行时类的对象 Field id = clazz.getField(\"id\");\t//只能获取public类型的属性 id.set(p,1001); System.out.println(id.get(p)); 调用运行时类中的指定属性： 1 2 3 4 5 6 7 Class\u003cPerson\u003e clazz = Person.class; Person p = clazz.newInstance();\t//创建运行时类的对象 //获取运行时类中指定变量名的属性 Field name = clazz.getDeclaredField(\"name\");\tname.setAccessible(true); name.set(p,\"Tom\"); System.out.println(name.get(p)); 调用运行时类中的指定属性： 1 2 3 4 5 6 7 8 9 10 Class\u003cPerson\u003e clazz = Person.class; Person p = clazz.newInstance();\t//创建运行时类的对象 Method show = clazz.getDeclaredMethod(\"show\", String.class); show.setAccessible(true); String nation = (String) show.invoke(p,\"中国\"); System.out.println(nation); System.out.println(\"*****************\"); Method showDest = clazz.getDeclaredMethod(\"showDest\"); showDest.setAccessible(true); showDest.invoke(Person.class); 反射和泛型： 1 2 3 4 5 Class\u003cPerson\u003e clazz = Person.class; Constructor\u003cPerson\u003e declaredConstructor = clazz.getDeclaredConstructor(String.class); declaredConstructor.setAccessible(true); Person person = declaredConstructor.newInstance(\"Tom\"); System.out.println(person); 父类： 1 2 3 4 5 6 7 8 9 10 public class Creature\u003cT\u003e implements Serializable { private char gender; public double weight; private void breath(){ System.out.println(\"生物呼吸\"); } public void eat(){ System.out.println(\"生物吃东西\"); } } 实现类： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @MyAnnotation(value = \"hi\") public class Person extends Creature\u003cString\u003e implements Comparable\u003cString\u003e,MyInterface { private String name; int age; public int id; public Person() { } @MyAnnotation(value = \"abc\") private Person(String name) { this.name = name; } @MyAnnotation Person(String name, int age) { this.name = name; this.age = age; } @MyAnnotation private String show(String nation){ return nation; } public String display(String interests){ return interests; } @Override public void info() throws RuntimeException { System.out.println(\"我是一个人\"); } @Override public int compareTo(String o) { return 0; } private static void showDest(){ System.out.println(\"haha\"); } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + \", id=\" + id + '}'; } } 自定义注解： 1 2 3 4 5 @Target({ElementType.TYPE, ElementType.FIELD,ElementType.METHOD,ElementType.PARAMETER,ElementType.CONSTRUCTOR,ElementType.LOCAL_VARIABLE}) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotation { String value() default \"hello\"; } ","description":"","tags":["hugo"],"title":"Java基础知识","uri":"/post/1.java/"}]
